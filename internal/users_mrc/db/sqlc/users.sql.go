// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: users.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const changePassword = `-- name: ChangePassword :exec
UPDATE users
SET
    password = COALESCE($1, password)
WHERE id = $2
`

type ChangePasswordParams struct {
	Password pgtype.Text `json:"password"`
	ID       pgtype.UUID `json:"id"`
}

func (q *Queries) ChangePassword(ctx context.Context, arg ChangePasswordParams) error {
	_, err := q.db.Exec(ctx, changePassword, arg.Password, arg.ID)
	return err
}

const countPremiumUsers = `-- name: CountPremiumUsers :one
SELECT COUNT(*) FROM groups g
                         JOIN user_groups ug ON g.id = ug.group_id
                         JOIN users u ON u.id = ug.user_id
WHERE g.name = 'premium_users'
`

func (q *Queries) CountPremiumUsers(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countPremiumUsers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUsersByGroup = `-- name: CountUsersByGroup :one
SELECT COUNT(*) FROM groups g
                         JOIN user_groups ug ON g.id = ug.group_id
                         JOIN users u ON u.id = ug.user_id
WHERE g.name = $1
`

func (q *Queries) CountUsersByGroup(ctx context.Context, name string) (int64, error) {
	row := q.db.QueryRow(ctx, countUsersByGroup, name)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUsersChurn30D = `-- name: CountUsersChurn30D :one
SELECT COUNT(*) FROM users
WHERE last_token_update < NOW() - INTERVAL '30 days' AND is_active = true
`

func (q *Queries) CountUsersChurn30D(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countUsersChurn30D)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
    email,
    user_type,
    password,
    last_name,
    first_name,
    auth_source,
    sexy,
    last_token_update
) VALUES
    ($1, $2, $3, $4, $5, $6, $7, NOW())
    RETURNING id, email, first_name, last_name, password, is_deleted, auth_source, updated_at, last_token_update, verified_email, user_type, is_banned, date_joined, sexy
`

type CreateUserParams struct {
	Email      string        `json:"email"`
	UserType   NullUserTypes `json:"user_type"`
	Password   string        `json:"password"`
	LastName   pgtype.Text   `json:"last_name"`
	FirstName  pgtype.Text   `json:"first_name"`
	AuthSource string        `json:"auth_source"`
	Sexy       NullSexy      `json:"sexy"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Email,
		arg.UserType,
		arg.Password,
		arg.LastName,
		arg.FirstName,
		arg.AuthSource,
		arg.Sexy,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.Password,
		&i.IsDeleted,
		&i.AuthSource,
		&i.UpdatedAt,
		&i.LastTokenUpdate,
		&i.VerifiedEmail,
		&i.UserType,
		&i.IsBanned,
		&i.DateJoined,
		&i.Sexy,
	)
	return i, err
}

const deleteUserByEmail = `-- name: DeleteUserByEmail :exec
DELETE FROM users WHERE email = $1
`

func (q *Queries) DeleteUserByEmail(ctx context.Context, email string) error {
	_, err := q.db.Exec(ctx, deleteUserByEmail, email)
	return err
}

const deleteUserById = `-- name: DeleteUserById :exec
DELETE FROM users WHERE id = $1
`

func (q *Queries) DeleteUserById(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteUserById, id)
	return err
}

const findUsers = `-- name: FindUsers :many
SELECT u.id, u.email, u.first_name, u.last_name, u.password, u.is_deleted, u.auth_source, u.updated_at, u.last_token_update, u.verified_email, u.user_type, u.is_banned, u.date_joined, u.sexy
FROM users u
         JOIN user_groups ug ON u.id = ug.user_id
         JOIN groups g ON ug.group_id = g.id
WHERE g.name = $1
  AND (u.email ILIKE '%' || $2 || '%')
    LIMIT $3 OFFSET $4
`

type FindUsersParams struct {
	Name    string      `json:"name"`
	Column2 pgtype.Text `json:"column_2"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

func (q *Queries) FindUsers(ctx context.Context, arg FindUsersParams) ([]User, error) {
	rows, err := q.db.Query(ctx, findUsers,
		arg.Name,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.FirstName,
			&i.LastName,
			&i.Password,
			&i.IsDeleted,
			&i.AuthSource,
			&i.UpdatedAt,
			&i.LastTokenUpdate,
			&i.VerifiedEmail,
			&i.UserType,
			&i.IsBanned,
			&i.DateJoined,
			&i.Sexy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUsers = `-- name: GetAllUsers :many
SELECT
    u.id,
    u.email,
    u.verified_email,
    u.auth_source,
    u.date_joined,
    u.is_deleted,
    u.user_type
FROM users u
         LEFT JOIN user_groups ug ON u.id = ug.user_id
         LEFT JOIN groups g ON ug.group_id = g.id
WHERE g.name IN ('job_seekers', 'companies', 'premium_users')
GROUP BY
    u.id, u.email
ORDER BY
    u.id
    LIMIT $1 OFFSET $2
`

type GetAllUsersParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetAllUsersRow struct {
	ID            pgtype.UUID        `json:"id"`
	Email         string             `json:"email"`
	VerifiedEmail pgtype.Bool        `json:"verified_email"`
	AuthSource    string             `json:"auth_source"`
	DateJoined    pgtype.Timestamptz `json:"date_joined"`
	IsDeleted     pgtype.Bool        `json:"is_deleted"`
	UserType      NullUserTypes      `json:"user_type"`
}

func (q *Queries) GetAllUsers(ctx context.Context, arg GetAllUsersParams) ([]GetAllUsersRow, error) {
	rows, err := q.db.Query(ctx, getAllUsers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllUsersRow{}
	for rows.Next() {
		var i GetAllUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.VerifiedEmail,
			&i.AuthSource,
			&i.DateJoined,
			&i.IsDeleted,
			&i.UserType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUsersAndRoles = `-- name: GetAllUsersAndRoles :many
SELECT
    u.id,
    u.email,
    u.verified_email,
    u.auth_source,
    u.date_joined,
    u.is_deleted,
    u.user_type,
    COALESCE(ARRAY_AGG(g.name), '{}') AS groups
FROM users u
         LEFT JOIN user_groups ug ON u.id = ug.user_id
         LEFT JOIN groups g ON ug.group_id = g.id
WHERE g.name IN ('job_seekers', 'companies', 'premium_users')
GROUP BY
    u.id, u.email
ORDER BY
    u.id
    LIMIT $1 OFFSET $2
`

type GetAllUsersAndRolesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetAllUsersAndRolesRow struct {
	ID            pgtype.UUID        `json:"id"`
	Email         string             `json:"email"`
	VerifiedEmail pgtype.Bool        `json:"verified_email"`
	AuthSource    string             `json:"auth_source"`
	DateJoined    pgtype.Timestamptz `json:"date_joined"`
	IsDeleted     pgtype.Bool        `json:"is_deleted"`
	UserType      NullUserTypes      `json:"user_type"`
	Groups        interface{}        `json:"groups"`
}

func (q *Queries) GetAllUsersAndRoles(ctx context.Context, arg GetAllUsersAndRolesParams) ([]GetAllUsersAndRolesRow, error) {
	rows, err := q.db.Query(ctx, getAllUsersAndRoles, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllUsersAndRolesRow{}
	for rows.Next() {
		var i GetAllUsersAndRolesRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.VerifiedEmail,
			&i.AuthSource,
			&i.DateJoined,
			&i.IsDeleted,
			&i.UserType,
			&i.Groups,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUsersByRole = `-- name: GetAllUsersByRole :many
SELECT u.id, u.email, u.first_name, u.last_name, u.password, u.is_deleted, u.auth_source, u.updated_at, u.last_token_update, u.verified_email, u.user_type, u.is_banned, u.date_joined, u.sexy
FROM users u
         JOIN user_groups ug ON u.id = ug.user_id
         JOIN groups g ON ug.group_id = g.id
WHERE g.name = $1
    LIMIT $2 OFFSET $3
`

type GetAllUsersByRoleParams struct {
	Name   string `json:"name"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) GetAllUsersByRole(ctx context.Context, arg GetAllUsersByRoleParams) ([]User, error) {
	rows, err := q.db.Query(ctx, getAllUsersByRole, arg.Name, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.FirstName,
			&i.LastName,
			&i.Password,
			&i.IsDeleted,
			&i.AuthSource,
			&i.UpdatedAt,
			&i.LastTokenUpdate,
			&i.VerifiedEmail,
			&i.UserType,
			&i.IsBanned,
			&i.DateJoined,
			&i.Sexy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrdinaryUsersCount = `-- name: GetOrdinaryUsersCount :one
SELECT COUNT(u.id) AS ordinary_users_count
FROM users u
         JOIN user_groups ug ON u.id = ug.user_id
         JOIN groups g ON ug.group_id = g.id
WHERE g.name = $1
`

func (q *Queries) GetOrdinaryUsersCount(ctx context.Context, name string) (int64, error) {
	row := q.db.QueryRow(ctx, getOrdinaryUsersCount, name)
	var ordinary_users_count int64
	err := row.Scan(&ordinary_users_count)
	return ordinary_users_count, err
}

const getUserAndGroupsByEmail = `-- name: GetUserAndGroupsByEmail :one
SELECT
    u.id,
    u.email,
    u.verified_email,
    u.first_name,
    u.last_name,
    u.auth_source,
    u.date_joined,
    u.is_deleted,
    u.user_type,
    COALESCE(ARRAY_AGG(g.name), '{}') AS groups
FROM users u
         LEFT JOIN user_groups ug ON u.id = ug.user_id
         LEFT JOIN groups g ON ug.group_id = g.id
WHERE u.email = $1
GROUP BY
    u.id, u.email
`

type GetUserAndGroupsByEmailRow struct {
	ID            pgtype.UUID        `json:"id"`
	Email         string             `json:"email"`
	VerifiedEmail pgtype.Bool        `json:"verified_email"`
	FirstName     pgtype.Text        `json:"first_name"`
	LastName      pgtype.Text        `json:"last_name"`
	AuthSource    string             `json:"auth_source"`
	DateJoined    pgtype.Timestamptz `json:"date_joined"`
	IsDeleted     pgtype.Bool        `json:"is_deleted"`
	UserType      NullUserTypes      `json:"user_type"`
	Groups        interface{}        `json:"groups"`
}

func (q *Queries) GetUserAndGroupsByEmail(ctx context.Context, email string) (GetUserAndGroupsByEmailRow, error) {
	row := q.db.QueryRow(ctx, getUserAndGroupsByEmail, email)
	var i GetUserAndGroupsByEmailRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.VerifiedEmail,
		&i.FirstName,
		&i.LastName,
		&i.AuthSource,
		&i.DateJoined,
		&i.IsDeleted,
		&i.UserType,
		&i.Groups,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, first_name, last_name, password, is_deleted, auth_source, updated_at, last_token_update, verified_email, user_type, is_banned, date_joined, sexy FROM users
WHERE email = $1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.Password,
		&i.IsDeleted,
		&i.AuthSource,
		&i.UpdatedAt,
		&i.LastTokenUpdate,
		&i.VerifiedEmail,
		&i.UserType,
		&i.IsBanned,
		&i.DateJoined,
		&i.Sexy,
	)
	return i, err
}

const getUserById = `-- name: GetUserById :one
SELECT id, email, first_name, last_name, password, is_deleted, auth_source, updated_at, last_token_update, verified_email, user_type, is_banned, date_joined, sexy FROM users
WHERE id = $1
`

func (q *Queries) GetUserById(ctx context.Context, id pgtype.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUserById, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.Password,
		&i.IsDeleted,
		&i.AuthSource,
		&i.UpdatedAt,
		&i.LastTokenUpdate,
		&i.VerifiedEmail,
		&i.UserType,
		&i.IsBanned,
		&i.DateJoined,
		&i.Sexy,
	)
	return i, err
}

const hideUserByEmail = `-- name: HideUserByEmail :exec
UPDATE users
SET
    is_deleted = $2
WHERE email = $1
`

type HideUserByEmailParams struct {
	Email     string      `json:"email"`
	IsDeleted pgtype.Bool `json:"is_deleted"`
}

func (q *Queries) HideUserByEmail(ctx context.Context, arg HideUserByEmailParams) error {
	_, err := q.db.Exec(ctx, hideUserByEmail, arg.Email, arg.IsDeleted)
	return err
}

const hideUserById = `-- name: HideUserById :exec
UPDATE users
SET
    is_deleted = $2
WHERE id = $1
`

type HideUserByIdParams struct {
	ID        pgtype.UUID `json:"id"`
	IsDeleted pgtype.Bool `json:"is_deleted"`
}

func (q *Queries) HideUserById(ctx context.Context, arg HideUserByIdParams) error {
	_, err := q.db.Exec(ctx, hideUserById, arg.ID, arg.IsDeleted)
	return err
}

const lastTokenUpdate = `-- name: LastTokenUpdate :exec
UPDATE users
SET
    last_token_update = NOW()
WHERE id = $1
`

func (q *Queries) LastTokenUpdate(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, lastTokenUpdate, id)
	return err
}

const newUsersLast24H = `-- name: NewUsersLast24H :one
SELECT COUNT(id) AS new_users_last_24h
FROM users
WHERE date_joined >= NOW() - INTERVAL '1 day'
`

func (q *Queries) NewUsersLast24H(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, newUsersLast24H)
	var new_users_last_24h int64
	err := row.Scan(&new_users_last_24h)
	return new_users_last_24h, err
}

const searchUsers = `-- name: SearchUsers :many
SELECT
    u.id,
    u.email,
    u.verified_email,
    u.auth_source,
    u.date_joined,
    u.is_deleted,
    u.user_type,
    COALESCE(ARRAY_AGG(g.name), '{}') AS groups
FROM
    users u
        LEFT JOIN
    user_groups ug ON u.id = ug.user_id
        LEFT JOIN
    groups g ON ug.group_id = g.id
WHERE
    (u.email ILIKE '%' || $1 || '%')
  AND g.name IN ('job_seekers', 'companies', 'premium_users')
GROUP BY
    u.id, u.email
ORDER BY
    u.id
    LIMIT $2 OFFSET $3
`

type SearchUsersParams struct {
	Column1 pgtype.Text `json:"column_1"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

type SearchUsersRow struct {
	ID            pgtype.UUID        `json:"id"`
	Email         string             `json:"email"`
	VerifiedEmail pgtype.Bool        `json:"verified_email"`
	AuthSource    string             `json:"auth_source"`
	DateJoined    pgtype.Timestamptz `json:"date_joined"`
	IsDeleted     pgtype.Bool        `json:"is_deleted"`
	UserType      NullUserTypes      `json:"user_type"`
	Groups        interface{}        `json:"groups"`
}

func (q *Queries) SearchUsers(ctx context.Context, arg SearchUsersParams) ([]SearchUsersRow, error) {
	rows, err := q.db.Query(ctx, searchUsers, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchUsersRow{}
	for rows.Next() {
		var i SearchUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.VerifiedEmail,
			&i.AuthSource,
			&i.DateJoined,
			&i.IsDeleted,
			&i.UserType,
			&i.Groups,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUserByEmail = `-- name: UpdateUserByEmail :one
UPDATE users
SET
    first_name = COALESCE($1, first_name),
    last_name = COALESCE($2, last_name),
    verified_email = COALESCE($3, verified_email),
    updated_at = NOW()
WHERE email = $4
    RETURNING id, email, first_name, last_name, password, is_deleted, auth_source, updated_at, last_token_update, verified_email, user_type, is_banned, date_joined, sexy
`

type UpdateUserByEmailParams struct {
	FirstName     pgtype.Text `json:"first_name"`
	LastName      pgtype.Text `json:"last_name"`
	VerifiedEmail pgtype.Bool `json:"verified_email"`
	Email         string      `json:"email"`
}

func (q *Queries) UpdateUserByEmail(ctx context.Context, arg UpdateUserByEmailParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserByEmail,
		arg.FirstName,
		arg.LastName,
		arg.VerifiedEmail,
		arg.Email,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.Password,
		&i.IsDeleted,
		&i.AuthSource,
		&i.UpdatedAt,
		&i.LastTokenUpdate,
		&i.VerifiedEmail,
		&i.UserType,
		&i.IsBanned,
		&i.DateJoined,
		&i.Sexy,
	)
	return i, err
}

const updateUserById = `-- name: UpdateUserById :one
UPDATE users
SET
    first_name = COALESCE($1, first_name),
    last_name = COALESCE($2, last_name),
    verified_email = COALESCE($3, verified_email),
    updated_at = NOW()
WHERE id = $4
    RETURNING id, email, first_name, last_name, password, is_deleted, auth_source, updated_at, last_token_update, verified_email, user_type, is_banned, date_joined, sexy
`

type UpdateUserByIdParams struct {
	FirstName     pgtype.Text `json:"first_name"`
	LastName      pgtype.Text `json:"last_name"`
	VerifiedEmail pgtype.Bool `json:"verified_email"`
	ID            pgtype.UUID `json:"id"`
}

func (q *Queries) UpdateUserById(ctx context.Context, arg UpdateUserByIdParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserById,
		arg.FirstName,
		arg.LastName,
		arg.VerifiedEmail,
		arg.ID,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.Password,
		&i.IsDeleted,
		&i.AuthSource,
		&i.UpdatedAt,
		&i.LastTokenUpdate,
		&i.VerifiedEmail,
		&i.UserType,
		&i.IsBanned,
		&i.DateJoined,
		&i.Sexy,
	)
	return i, err
}

const userExists = `-- name: UserExists :one
SELECT EXISTS (
    SELECT id, email, first_name, last_name, password, is_deleted, auth_source, updated_at, last_token_update, verified_email, user_type, is_banned, date_joined, sexy FROM users WHERE email = $1
)
`

func (q *Queries) UserExists(ctx context.Context, email string) (bool, error) {
	row := q.db.QueryRow(ctx, userExists, email)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const userGrowthPerYear = `-- name: UserGrowthPerYear :many
SELECT
    TO_CHAR(DATE_TRUNC('month', date_joined), 'MM') AS month,
    COUNT(*) AS user_count
FROM
    users
GROUP BY
    month
ORDER BY
    month
`

type UserGrowthPerYearRow struct {
	Month     string `json:"month"`
	UserCount int64  `json:"user_count"`
}

func (q *Queries) UserGrowthPerYear(ctx context.Context) ([]UserGrowthPerYearRow, error) {
	rows, err := q.db.Query(ctx, userGrowthPerYear)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserGrowthPerYearRow{}
	for rows.Next() {
		var i UserGrowthPerYearRow
		if err := rows.Scan(&i.Month, &i.UserCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
